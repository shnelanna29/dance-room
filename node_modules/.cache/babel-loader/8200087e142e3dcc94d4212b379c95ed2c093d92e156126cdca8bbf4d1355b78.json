{"ast":null,"code":"// src/streamedQuery.ts\nimport { addToEnd } from \"./utils.js\";\nfunction streamedQuery({\n  streamFn,\n  refetchMode = \"reset\",\n  reducer = (items, chunk) => addToEnd(items, chunk),\n  initialValue = []\n}) {\n  return async context => {\n    const query = context.client.getQueryCache().find({\n      queryKey: context.queryKey,\n      exact: true\n    });\n    const isRefetch = !!query && query.state.data !== void 0;\n    if (isRefetch && refetchMode === \"reset\") {\n      query.setState({\n        status: \"pending\",\n        data: void 0,\n        error: null,\n        fetchStatus: \"fetching\"\n      });\n    }\n    let result = initialValue;\n    const stream = await streamFn(context);\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break;\n      }\n      if (!isRefetch || refetchMode !== \"replace\") {\n        context.client.setQueryData(context.queryKey, prev => reducer(prev === void 0 ? initialValue : prev, chunk));\n      }\n      result = reducer(result, chunk);\n    }\n    if (isRefetch && refetchMode === \"replace\" && !context.signal.aborted) {\n      context.client.setQueryData(context.queryKey, result);\n    }\n    return context.client.getQueryData(context.queryKey);\n  };\n}\nexport { streamedQuery };","map":{"version":3,"names":["addToEnd","streamedQuery","streamFn","refetchMode","reducer","items","chunk","initialValue","context","query","client","getQueryCache","find","queryKey","exact","isRefetch","state","data","setState","status","error","fetchStatus","result","stream","signal","aborted","setQueryData","prev","getQueryData"],"sources":["C:\\Users\\Admin\\Desktop\\Диск D\\колледж\\Бутов\\DR\\node_modules\\@tanstack\\query-core\\src\\streamedQuery.ts"],"sourcesContent":["import { addToEnd } from './utils'\nimport type { QueryFunction, QueryFunctionContext, QueryKey } from './types'\n\ntype BaseStreamedQueryParams<TQueryFnData, TQueryKey extends QueryKey> = {\n  streamFn: (\n    context: QueryFunctionContext<TQueryKey>,\n  ) => AsyncIterable<TQueryFnData> | Promise<AsyncIterable<TQueryFnData>>\n  refetchMode?: 'append' | 'reset' | 'replace'\n}\n\ntype SimpleStreamedQueryParams<\n  TQueryFnData,\n  TQueryKey extends QueryKey,\n> = BaseStreamedQueryParams<TQueryFnData, TQueryKey> & {\n  reducer?: never\n  initialValue?: never\n}\n\ntype ReducibleStreamedQueryParams<\n  TQueryFnData,\n  TData,\n  TQueryKey extends QueryKey,\n> = BaseStreamedQueryParams<TQueryFnData, TQueryKey> & {\n  reducer: (acc: TData, chunk: TQueryFnData) => TData\n  initialValue: TData\n}\n\ntype StreamedQueryParams<TQueryFnData, TData, TQueryKey extends QueryKey> =\n  | SimpleStreamedQueryParams<TQueryFnData, TQueryKey>\n  | ReducibleStreamedQueryParams<TQueryFnData, TData, TQueryKey>\n\n/**\n * This is a helper function to create a query function that streams data from an AsyncIterable.\n * Data will be an Array of all the chunks received.\n * The query will be in a 'pending' state until the first chunk of data is received, but will go to 'success' after that.\n * The query will stay in fetchStatus 'fetching' until the stream ends.\n * @param queryFn - The function that returns an AsyncIterable to stream data from.\n * @param refetchMode - Defines how re-fetches are handled.\n * Defaults to `'reset'`, erases all data and puts the query back into `pending` state.\n * Set to `'append'` to append new data to the existing data.\n * Set to `'replace'` to write all data to the cache once the stream ends.\n * @param reducer - A function to reduce the streamed chunks into the final data.\n * Defaults to a function that appends chunks to the end of the array.\n * @param initialValue - Initial value to be used while the first chunk is being fetched.\n */\nexport function streamedQuery<\n  TQueryFnData = unknown,\n  TData = Array<TQueryFnData>,\n  TQueryKey extends QueryKey = QueryKey,\n>({\n  streamFn,\n  refetchMode = 'reset',\n  reducer = (items, chunk) =>\n    addToEnd(items as Array<TQueryFnData>, chunk) as TData,\n  initialValue = [] as TData,\n}: StreamedQueryParams<TQueryFnData, TData, TQueryKey>): QueryFunction<\n  TData,\n  TQueryKey\n> {\n  return async (context) => {\n    const query = context.client\n      .getQueryCache()\n      .find({ queryKey: context.queryKey, exact: true })\n    const isRefetch = !!query && query.state.data !== undefined\n    if (isRefetch && refetchMode === 'reset') {\n      query.setState({\n        status: 'pending',\n        data: undefined,\n        error: null,\n        fetchStatus: 'fetching',\n      })\n    }\n\n    let result = initialValue\n\n    const stream = await streamFn(context)\n\n    for await (const chunk of stream) {\n      if (context.signal.aborted) {\n        break\n      }\n\n      // don't append to the cache directly when replace-refetching\n      if (!isRefetch || refetchMode !== 'replace') {\n        context.client.setQueryData<TData>(context.queryKey, (prev) =>\n          reducer(prev === undefined ? initialValue : prev, chunk),\n        )\n      }\n      result = reducer(result, chunk)\n    }\n\n    // finalize result: replace-refetching needs to write to the cache\n    if (isRefetch && refetchMode === 'replace' && !context.signal.aborted) {\n      context.client.setQueryData<TData>(context.queryKey, result)\n    }\n\n    return context.client.getQueryData(context.queryKey)!\n  }\n}\n"],"mappings":";AAAA,SAASA,QAAA,QAAgB;AA6ClB,SAASC,cAId;EACAC,QAAA;EACAC,WAAA,GAAc;EACdC,OAAA,GAAUA,CAACC,KAAA,EAAOC,KAAA,KAChBN,QAAA,CAASK,KAAA,EAA8BC,KAAK;EAC9CC,YAAA,GAAe;AACjB,GAGE;EACA,OAAO,MAAOC,OAAA,IAAY;IACxB,MAAMC,KAAA,GAAQD,OAAA,CAAQE,MAAA,CACnBC,aAAA,CAAc,EACdC,IAAA,CAAK;MAAEC,QAAA,EAAUL,OAAA,CAAQK,QAAA;MAAUC,KAAA,EAAO;IAAK,CAAC;IACnD,MAAMC,SAAA,GAAY,CAAC,CAACN,KAAA,IAASA,KAAA,CAAMO,KAAA,CAAMC,IAAA,KAAS;IAClD,IAAIF,SAAA,IAAaZ,WAAA,KAAgB,SAAS;MACxCM,KAAA,CAAMS,QAAA,CAAS;QACbC,MAAA,EAAQ;QACRF,IAAA,EAAM;QACNG,KAAA,EAAO;QACPC,WAAA,EAAa;MACf,CAAC;IACH;IAEA,IAAIC,MAAA,GAASf,YAAA;IAEb,MAAMgB,MAAA,GAAS,MAAMrB,QAAA,CAASM,OAAO;IAErC,iBAAiBF,KAAA,IAASiB,MAAA,EAAQ;MAChC,IAAIf,OAAA,CAAQgB,MAAA,CAAOC,OAAA,EAAS;QAC1B;MACF;MAGA,IAAI,CAACV,SAAA,IAAaZ,WAAA,KAAgB,WAAW;QAC3CK,OAAA,CAAQE,MAAA,CAAOgB,YAAA,CAAoBlB,OAAA,CAAQK,QAAA,EAAWc,IAAA,IACpDvB,OAAA,CAAQuB,IAAA,KAAS,SAAYpB,YAAA,GAAeoB,IAAA,EAAMrB,KAAK,CACzD;MACF;MACAgB,MAAA,GAASlB,OAAA,CAAQkB,MAAA,EAAQhB,KAAK;IAChC;IAGA,IAAIS,SAAA,IAAaZ,WAAA,KAAgB,aAAa,CAACK,OAAA,CAAQgB,MAAA,CAAOC,OAAA,EAAS;MACrEjB,OAAA,CAAQE,MAAA,CAAOgB,YAAA,CAAoBlB,OAAA,CAAQK,QAAA,EAAUS,MAAM;IAC7D;IAEA,OAAOd,OAAA,CAAQE,MAAA,CAAOkB,YAAA,CAAapB,OAAA,CAAQK,QAAQ;EACrD;AACF","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"// src/timeoutManager.ts\nvar defaultTimeoutProvider = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: timeoutId => clearTimeout(timeoutId),\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: intervalId => clearInterval(intervalId)\n};\nvar TimeoutManager = class {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider = defaultTimeoutProvider;\n  #providerCalled = false;\n  setTimeoutProvider(provider) {\n    if (process.env.NODE_ENV !== \"production\") {\n      if (this.#providerCalled && provider !== this.#provider) {\n        console.error(`[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`, {\n          previous: this.#provider,\n          provider\n        });\n      }\n    }\n    this.#provider = provider;\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = false;\n    }\n  }\n  setTimeout(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setTimeout(callback, delay);\n  }\n  clearTimeout(timeoutId) {\n    this.#provider.clearTimeout(timeoutId);\n  }\n  setInterval(callback, delay) {\n    if (process.env.NODE_ENV !== \"production\") {\n      this.#providerCalled = true;\n    }\n    return this.#provider.setInterval(callback, delay);\n  }\n  clearInterval(intervalId) {\n    this.#provider.clearInterval(intervalId);\n  }\n};\nvar timeoutManager = new TimeoutManager();\nfunction systemSetTimeoutZero(callback) {\n  setTimeout(callback, 0);\n}\nexport { TimeoutManager, defaultTimeoutProvider, systemSetTimeoutZero, timeoutManager };","map":{"version":3,"names":["defaultTimeoutProvider","setTimeout","callback","delay","clearTimeout","timeoutId","setInterval","clearInterval","intervalId","TimeoutManager","provider","providerCalled","setTimeoutProvider","process","env","NODE_ENV","console","error","previous","timeoutManager","systemSetTimeoutZero"],"sources":["C:\\Users\\Admin\\Desktop\\Диск D\\колледж\\Бутов\\DR\\node_modules\\@tanstack\\query-core\\src\\timeoutManager.ts"],"sourcesContent":["/**\n * {@link TimeoutManager} does not support passing arguments to the callback.\n *\n * `(_: void)` is the argument type inferred by TypeScript's default typings for\n * `setTimeout(cb, number)`.\n * If we don't accept a single void argument, then\n * `new Promise(resolve => timeoutManager.setTimeout(resolve, N))` is a type error.\n */\nexport type TimeoutCallback = (_: void) => void\n\n/**\n * Wrapping `setTimeout` is awkward from a typing perspective because platform\n * typings may extend the return type of `setTimeout`. For example, NodeJS\n * typings add `NodeJS.Timeout`; but a non-default `timeoutManager` may not be\n * able to return such a type.\n */\nexport type ManagedTimerId = number | { [Symbol.toPrimitive]: () => number }\n\n/**\n * Backend for timer functions.\n */\nexport type TimeoutProvider<TTimerId extends ManagedTimerId = ManagedTimerId> =\n  {\n    readonly setTimeout: (callback: TimeoutCallback, delay: number) => TTimerId\n    readonly clearTimeout: (timeoutId: TTimerId | undefined) => void\n\n    readonly setInterval: (callback: TimeoutCallback, delay: number) => TTimerId\n    readonly clearInterval: (intervalId: TTimerId | undefined) => void\n  }\n\nexport const defaultTimeoutProvider: TimeoutProvider<\n  ReturnType<typeof setTimeout>\n> = {\n  // We need the wrapper function syntax below instead of direct references to\n  // global setTimeout etc.\n  //\n  // BAD: `setTimeout: setTimeout`\n  // GOOD: `setTimeout: (cb, delay) => setTimeout(cb, delay)`\n  //\n  // If we use direct references here, then anything that wants to spy on or\n  // replace the global setTimeout (like tests) won't work since we'll already\n  // have a hard reference to the original implementation at the time when this\n  // file was imported.\n  setTimeout: (callback, delay) => setTimeout(callback, delay),\n  clearTimeout: (timeoutId) => clearTimeout(timeoutId),\n\n  setInterval: (callback, delay) => setInterval(callback, delay),\n  clearInterval: (intervalId) => clearInterval(intervalId),\n}\n\n/**\n * Allows customization of how timeouts are created.\n *\n * @tanstack/query-core makes liberal use of timeouts to implement `staleTime`\n * and `gcTime`. The default TimeoutManager provider uses the platform's global\n * `setTimeout` implementation, which is known to have scalability issues with\n * thousands of timeouts on the event loop.\n *\n * If you hit this limitation, consider providing a custom TimeoutProvider that\n * coalesces timeouts.\n */\nexport class TimeoutManager implements Omit<TimeoutProvider, 'name'> {\n  // We cannot have TimeoutManager<T> as we must instantiate it with a concrete\n  // type at app boot; and if we leave that type, then any new timer provider\n  // would need to support ReturnType<typeof setTimeout>, which is infeasible.\n  //\n  // We settle for type safety for the TimeoutProvider type, and accept that\n  // this class is unsafe internally to allow for extension.\n  #provider: TimeoutProvider<any> = defaultTimeoutProvider\n  #providerCalled = false\n\n  setTimeoutProvider<TTimerId extends ManagedTimerId>(\n    provider: TimeoutProvider<TTimerId>,\n  ): void {\n    if (process.env.NODE_ENV !== 'production') {\n      if (this.#providerCalled && provider !== this.#provider) {\n        // After changing providers, `clearTimeout` will not work as expected for\n        // timeouts from the previous provider.\n        //\n        // Since they may allocate the same timeout ID, clearTimeout may cancel an\n        // arbitrary different timeout, or unexpected no-op.\n        //\n        // We could protect against this by mixing the timeout ID bits\n        // deterministically with some per-provider bits.\n        //\n        // We could internally queue `setTimeout` calls to `TimeoutManager` until\n        // some API call to set the initial provider.\n        console.error(\n          `[timeoutManager]: Switching provider after calls to previous provider might result in unexpected behavior.`,\n          { previous: this.#provider, provider },\n        )\n      }\n    }\n\n    this.#provider = provider\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = false\n    }\n  }\n\n  setTimeout(callback: TimeoutCallback, delay: number): ManagedTimerId {\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = true\n    }\n    return this.#provider.setTimeout(callback, delay)\n  }\n\n  clearTimeout(timeoutId: ManagedTimerId | undefined): void {\n    this.#provider.clearTimeout(timeoutId)\n  }\n\n  setInterval(callback: TimeoutCallback, delay: number): ManagedTimerId {\n    if (process.env.NODE_ENV !== 'production') {\n      this.#providerCalled = true\n    }\n    return this.#provider.setInterval(callback, delay)\n  }\n\n  clearInterval(intervalId: ManagedTimerId | undefined): void {\n    this.#provider.clearInterval(intervalId)\n  }\n}\n\nexport const timeoutManager = new TimeoutManager()\n\n/**\n * In many cases code wants to delay to the next event loop tick; this is not\n * mediated by {@link timeoutManager}.\n *\n * This function is provided to make auditing the `tanstack/query-core` for\n * incorrect use of system `setTimeout` easier.\n */\nexport function systemSetTimeoutZero(callback: TimeoutCallback): void {\n  setTimeout(callback, 0)\n}\n"],"mappings":";AA8BO,IAAMA,sBAAA,GAET;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAWFC,UAAA,EAAYA,CAACC,QAAA,EAAUC,KAAA,KAAUF,UAAA,CAAWC,QAAA,EAAUC,KAAK;EAC3DC,YAAA,EAAeC,SAAA,IAAcD,YAAA,CAAaC,SAAS;EAEnDC,WAAA,EAAaA,CAACJ,QAAA,EAAUC,KAAA,KAAUG,WAAA,CAAYJ,QAAA,EAAUC,KAAK;EAC7DI,aAAA,EAAgBC,UAAA,IAAeD,aAAA,CAAcC,UAAU;AACzD;AAaO,IAAMC,cAAA,GAAN,MAA8D;EAAA;EAAA;EAAA;EAAA;EAAA;EAAA;EAOnE,CAAAC,QAAA,GAAkCV,sBAAA;EAClC,CAAAW,cAAA,GAAkB;EAElBC,mBACEF,QAAA,EACM;IACN,IAAIG,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzC,IAAI,KAAK,CAAAJ,cAAA,IAAmBD,QAAA,KAAa,KAAK,CAAAA,QAAA,EAAW;QAYvDM,OAAA,CAAQC,KAAA,CACN,8GACA;UAAEC,QAAA,EAAU,KAAK,CAAAR,QAAA;UAAWA;QAAS,CACvC;MACF;IACF;IAEA,KAAK,CAAAA,QAAA,GAAYA,QAAA;IACjB,IAAIG,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzC,KAAK,CAAAJ,cAAA,GAAkB;IACzB;EACF;EAEAV,WAAWC,QAAA,EAA2BC,KAAA,EAA+B;IACnE,IAAIU,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzC,KAAK,CAAAJ,cAAA,GAAkB;IACzB;IACA,OAAO,KAAK,CAAAD,QAAA,CAAUT,UAAA,CAAWC,QAAA,EAAUC,KAAK;EAClD;EAEAC,aAAaC,SAAA,EAA6C;IACxD,KAAK,CAAAK,QAAA,CAAUN,YAAA,CAAaC,SAAS;EACvC;EAEAC,YAAYJ,QAAA,EAA2BC,KAAA,EAA+B;IACpE,IAAIU,OAAA,CAAQC,GAAA,CAAIC,QAAA,KAAa,cAAc;MACzC,KAAK,CAAAJ,cAAA,GAAkB;IACzB;IACA,OAAO,KAAK,CAAAD,QAAA,CAAUJ,WAAA,CAAYJ,QAAA,EAAUC,KAAK;EACnD;EAEAI,cAAcC,UAAA,EAA8C;IAC1D,KAAK,CAAAE,QAAA,CAAUH,aAAA,CAAcC,UAAU;EACzC;AACF;AAEO,IAAMW,cAAA,GAAiB,IAAIV,cAAA,CAAe;AAS1C,SAASW,qBAAqBlB,QAAA,EAAiC;EACpED,UAAA,CAAWC,QAAA,EAAU,CAAC;AACxB","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}